/*
 * Copyright (c) 2016. Bottle Rocket LLC
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.bottlerocketstudios.vault.keys.storage;

import android.annotation.TargetApi;
import android.content.Context;
import android.os.Build;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyProperties;
import android.util.Log;

import com.bottlerocketstudios.vault.EncryptionConstants;

import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;

import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

/**
 * Use Android Keystore to keep the SecretKey. Requires user authentication to be enabled and
 * requires re-authentication at specified intervals.
 */
public class KeychainAuthenticatedKeyStorage implements KeyStorage {
    private static final String TAG = KeychainAuthenticatedKeyStorage.class.getSimpleName();

    private final String mKeyAlias;
    private final String mAlgorithm;
    private final String mBlockMode;
    private final String mPadding;
    private final int mAuthDurationSeconds;

    private final String mKeyLock = "keyLock";

    public KeychainAuthenticatedKeyStorage(String keyAlias, String algorithm, String blockMode, String padding, int authDurationSeconds) {
        mKeyAlias = keyAlias;
        mAlgorithm = algorithm;
        mBlockMode = blockMode;
        mPadding = padding;
        mAuthDurationSeconds = authDurationSeconds;
    }

    @Override
    public SecretKey loadKey(Context context) {
        SecretKey secretKey = null;
        synchronized (mKeyLock) {
            try {
                KeyStore keyStore = KeyStore.getInstance("AndroidKeyStore");
                keyStore.load(null);
                secretKey = (SecretKey) keyStore.getKey(mKeyAlias, null);
            } catch (KeyStoreException e) {
                Log.e(TAG, "Caught java.security.KeyStoreException", e);
            } catch (CertificateException e) {
                Log.e(TAG, "Caught java.security.cert.CertificateException", e);
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, "Caught java.security.NoSuchAlgorithmException", e);
            } catch (IOException e) {
                Log.e(TAG, "Caught java.io.IOException", e);
            } catch (UnrecoverableKeyException e) {
                Log.e(TAG, "Caught java.security.UnrecoverableKeyException", e);
            }
        }
        return secretKey;
    }

    @Override
    public boolean saveKey(Context context, SecretKey secretKey) {
        if (secretKey != null) {
            throw new IllegalArgumentException("Cannot be manually keyed. The key is generated by the Keystore itself. The argument secretKey must be null.");
        }
        return automaticallyCreateKey();
    }

    @TargetApi(Build.VERSION_CODES.M)
    private boolean automaticallyCreateKey() {
        synchronized (mKeyLock) {
            try {
                KeyStore keyStore = KeyStore.getInstance(EncryptionConstants.ANDROID_KEY_STORE);
                keyStore.load(null);
                KeyGenerator keyGenerator = KeyGenerator.getInstance(mAlgorithm, EncryptionConstants.ANDROID_KEY_STORE);

                keyGenerator.init(new KeyGenParameterSpec.Builder(mKeyAlias, KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                        .setBlockModes(mBlockMode)
                        .setUserAuthenticationRequired(true)
                        .setUserAuthenticationValidityDurationSeconds(mAuthDurationSeconds)
                        .setEncryptionPaddings(mPadding)
                        .build());

                return keyGenerator.generateKey() != null;
            } catch (KeyStoreException e) {
                Log.e(TAG, "Caught java.security.KeyStoreException", e);
            } catch (CertificateException e) {
                Log.e(TAG, "Caught java.security.cert.CertificateException", e);
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, "Caught java.security.NoSuchAlgorithmException", e);
            } catch (InvalidAlgorithmParameterException e) {
                Log.e(TAG, "Caught java.security.InvalidAlgorithmParameterException", e);
            } catch (NoSuchProviderException e) {
                Log.e(TAG, "Caught java.security.NoSuchProviderException", e);
            } catch (IOException e) {
                Log.e(TAG, "Caught java.io.IOException", e);
            }
        }
        return false;
    }

    @Override
    public void clearKey(Context context) {
        synchronized (mKeyLock) {
            try {
                KeyStore keyStore = KeyStore.getInstance(EncryptionConstants.ANDROID_KEY_STORE);
                keyStore.load(null);
                keyStore.deleteEntry(mKeyAlias);
            } catch (KeyStoreException e) {
                Log.e(TAG, "Caught java.security.KeyStoreException", e);
            } catch (CertificateException e) {
                Log.e(TAG, "Caught java.security.cert.CertificateException", e);
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, "Caught java.security.NoSuchAlgorithmException", e);
            } catch (IOException e) {
                Log.e(TAG, "Caught java.io.IOException", e);
            }
        }
    }

    @Override
    public boolean hasKey(Context context) {
        synchronized (mKeyLock) {
            try {
                KeyStore keyStore = KeyStore.getInstance(EncryptionConstants.ANDROID_KEY_STORE);
                keyStore.load(null);
                return keyStore.containsAlias(mKeyAlias);
            } catch (KeyStoreException e) {
                Log.e(TAG, "Caught java.security.KeyStoreException", e);
            } catch (CertificateException e) {
                Log.e(TAG, "Caught java.security.cert.CertificateException", e);
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, "Caught java.security.NoSuchAlgorithmException", e);
            } catch (IOException e) {
                Log.e(TAG, "Caught java.io.IOException", e);
            }
        }
        return false;
    }
}
